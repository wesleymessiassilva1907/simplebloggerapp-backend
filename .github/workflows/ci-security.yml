name: ci-security

on:
  workflow_call:
    inputs:
      node_version: { type: string, default: '20' }
      run_zap: { type: boolean, default: true }
      port: { type: string, default: '3000' }
      health_path: { type: string, default: '/healthz' }

permissions:
  contents: read
  security-events: write
  actions: read 

jobs:
  lint_test_sast_dast:
    runs-on: ubuntu-latest
    services:
      mongo:
        image: mongo:6
        ports: [ "27017:27017" ]
        options: >-
          --health-cmd="mongosh --eval 'db.runCommand({ ping: 1 })'"
          --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: 
          node-version: ${{ inputs.node_version }}
  
      - name: Instalar dependências
        run: npm install --no-fund --no-audit
          
      - run: npm ci
      - name: ESLint
        run: npx eslint . --max-warnings=0

      - name: CodeQL init
        uses: github/codeql-action/init@v3
        with: { languages: javascript }

      - name: CodeQL analyze
        uses: github/codeql-action/analyze@v3
        with: { category: /language:javascript }

      - name: Trivy (filesystem)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: fs
          scan-ref: .
          format: table
          severity: CRITICAL,HIGH
          ignore-unfixed: true
          exit-code: '1'

      - name: DB ping (fail fast)
        run: |
          for i in {1..10}; do
            if mongosh "mongodb://127.0.0.1:27017/blogger-ci" --eval "db.runCommand({ping:1})" --quiet; then
              exit 0
            fi
            sleep 2
          done
          echo "Mongo indisponível"; exit 1

      - name: Start API (for DAST) - fast fail + logs
        env:
          PORT: ${{ inputs.port }}
          # timeouts para o driver do Mongo não segurar a subida:
          MONGODB_URI: mongodb://127.0.0.1:27017/blogger-ci?serverSelectionTimeoutMS=2000&connectTimeoutMS=2000
          NODE_ENV: production
          JWT_SECRET: ci-secret
        run: |
          nohup node server.js >/tmp/app.log 2>&1 &
          # espere o endpoint de saúde (melhor que só "tcp:")
          npx -y wait-on@8 -t 60000 "http-get://127.0.0.1:${{ inputs.port }}${{ inputs.health_path }}" || {
            echo "---- /tmp/app.log (últimas linhas) ----"
            tail -n 200 /tmp/app.log || true
            exit 1
          }

      - name: Start API (for DAST)
        if: ${{ inputs.run_zap }}
        env:
          PORT: ${{ inputs.port }}
          MONGODB_URI: mongodb://127.0.0.1:27017/blogger-ci
          NODE_ENV: production
          JWT_SECRET: ci-secret
        run: |
          nohup npm start >/tmp/app.log 2>&1 &
          npx wait-on tcp:${{ inputs.port }}

      - name: ZAP Baseline
        if: ${{ inputs.run_zap }}
        uses: zaproxy/action-baseline@v0.14.0
        with:
          target: http://127.0.0.1:${{ inputs.port }}${{ inputs.health_path }}
          cmd_options: -a -m 2 -r zap-report.html
          fail_action: true
          artifact_name: zap_local_report

  osv_scan:
    uses: "google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@v2.2.2"
    permissions:
      actions: read
      security-events: write
      contents: read
    with:
      # args padrão (procura lockfiles recursivamente)
      scan-args: |-
        --recursive
        ./